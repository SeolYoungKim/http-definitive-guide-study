### Q1. 안전한 메서드의 구분?
3.3.1 안전한 메서드(p.61), 이게 RFC 오피셜인지 모르겠는데, get과 head는 안전하다고 함(혹은 안전하게 구현해야겠지).  
서버내에서 리소스에 변화가 이루어지지 않는 메서드(의미론적으론 그렇다)라고 하는데,  
우리는 서버 개발을 하다보면 요구사항에 의해 get시에 게시물 hit카운터를 올린다거나 하고있다.  
안전한 메서드 라는 구분이 정말 의미가 있는것 일까?  
나아가 Restful 한 API 를 구현하기 위해서 이것들은 정말 지양되어야 하는 행위일까?  

### Q2. vary 헤더
몇번 본적은 있지만 정확한 용도를 모르겠음.   
캐시와 관련된거같은데, 예를들어 vary: accept 라고 정의한다면 accept 가 달라질경우 캐시되지 않은 결과를 달라는것인지, 주겠다는 것인지?



### 정리
##### 메시지
메시지는 서버 클라이언트 사이를 흐른다.  
인바운드 아웃바운드 업스트림 다운스트림은 메시지의 방향을 의미하며  
인바운드는 서버를 기준으로 들어오는 데이터, 아웃바운드는 나가는 데이터(보통 방화벽의 경우 아웃바운드는 풀려있다.)  
데이터의 흐름은 업스트림에서 다운스트림으로 흐른다. 요청인지 응답인지는 상관없다.

메시지는 시작줄(start-line), 헤더, 본문(body)로 구성되며  

요청은
```ruby
GET /resources/name HTTP/1.1
Host: localhost:8080
Accept: text/html,application/json,application/xhtml+xml
Connection: keep-alive
Content-Length: 14

data,data,data

```
응답은
```ruby
HTTP/1.1 403 Forbidden
Server: Apache
Content-Type: text/html; charset=UTF-8
Keep-Alive: timeout=5, max=1000
Connection: Keep-Alive
Content-Length: 220

<!DOCTYPE HTML PUBLIC ...

```
각 줄은 캐리지 리턴으로 구분되며, 본문이 없어도 캐리지리턴을 포함해야한다.  
헤더도 여러줄로 표현할수 있으나, 새 줄 맨 앞에 탭 문자를 삽입해 구분한다.

##### 몇가지
GET 과 HEAD 는 거의 같지만 결정적인 차이는 응답 본문이 있느냐 없느냐의 차이이다.  
리소스의 존재 여부나 업데이트 확인이라던지 헤더 자체가 필요할경우 사용된다.  
일반적으로 HEAD는 사용되지 않지만 전략적으로는 컨텐츠의 길이가 너무 길면 가져오지 않는다거나 하는 판단에 도움을 줄수 있지 않을까?

POST 와 PUT 의 차이는 멱등성(idompotent)  
둘다 뭔가 생성하는 역할을 하지만 몇번 요청을 하더라도 같은 리소스 상태를 유지해야하는 PUT,
요청하는대로 생성 시도를 하는 POST   
자동으로 그렇게 되는것이 아니라 서버 개발자가 그렇게 구현해야 한다.

TRACE 는 책에선 말이 어렵지만 결과만 놓고보면 말 그대로 거쳐갔다 온 서버들의 요청과 응답을 그대로 돌려준다.  
사용자의 요청이 어떤 구성을 통해서 목적지까지 전달되는지를 확인할수 있다.  
디버그 로그 찍는 것과 비슷하다고 볼수있다.  
요청은 평범한 GET 과 같고, 응답은 요청 메시지를 그대로 돌려준다.  
만약 중간에 여러 프록시(혹은 게이트웨이 등 중간 전달자)가 끼어있다면 그 프록시의 요청도 포함하여 그대로 돌려준다.  
책에는 바디는 없어야 한다고 하지만 실은 들어갈수 있고, 응답에 그대로 다시 돌아온다. 구분하기 애매하므로 넣지 않는다.  
이것은 심각한 보안 위협이 될수 있기때문에 보통은 사용하지 않도록 꺼둔다.  

DELETE 는 다들 보자마자 생각하는 그것이 맞지만 응답은 생각한 그것이 아닐수도 있다.  
책에서도 지적하고 있는 부분인데, 삭제 요청을 수용하지만 그것을 진짜로 수행할지 말지, 혹은 실패될지 보장하지 않는다.(스펙이 그렇다)  
그러므로 DELETE 메서드를 작성할때 동기식으로 작성하기 보다는 비동기로 작성하고 202 Accepted 를 리턴하는게 어떨까.


##### check
- 책(p.55, 표3-1)에서 GET 은 바디를 포함하지 않았지만, 2014년 RFC 스펙이 변경되어 옵셔널이 되었다.
- 표3-1에는 PATCH가 없는데, 이는 Ruby on rails 의 진영의 주장에 의해 2010년 추가되어 책에는 반영이 늦은게 아닐까 싶다.


##### webdav 
생소하지만 HTTP 확장, 표준이며 주로 파일 관리에 이용된다.  
NAS 같은 곳에서 사용됨. HTTP 의 확장이기 때문에 80, 443을 사용한다.  
PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, DELETE, LOCK, UNLOCK 메소드 지원 

##### HTTP status code
일반적으로 1xx 은 정보, 2xx 은 성공, 3xx 은 리다이렉션, 4xx 은 클라이언트 에러, 5xx 은 서버 에러를 나타낸다.

- 100 Continue 
서버에게 요청을 보내고 서버가 요청을 받은 다음에도 추가적인 정보를 제공하기 위한 응답이다.  
클라이언트가 한번에 서버에게 큰 요청을 보내지 않게하기 위해 사용한다는데.. 쓸 이유가?  
예를들면 한번에 큰 파일을 전송할때 사용할수 있다는데, 미리 약속한 Content-Length 길이보다 작으면 파일전송 완료(다음 요청 없음), 해당 길이랑 같다면 전송 도중(다음 요청 발생), 길이보다 크다면 잘못된 작업으로 약속하고 사용할수 있다.  
헤더에 추가적으로 Expect를 포함하여 사용한다.  
애초에 이걸 사용해야 한다면 다른 방법을 사용하는게 좋지 않을까..  

- 201 Created  
POST, PUT 에 대응하는 코드
- 202 Accepted  
서버가 요청을 받긴 했는데, 서버의 처리는 클라이언트가 신경쓰지 않아도 되는 경우 사용.  
- 203 NonAuthoritative Information  
말이 어려운데, 간단히 하자면 응답을 주긴 했는데, 원본 리소스를 가져온게 아니라 제3자로부터 가져온 경우이다. 말하자면 서버에 붙은 캐시라던지. 비슷한 케이스로 nslookup을 했을때 볼수 있다.
- 204 No Content  
성공했고, 돌려줄 바디 없음

- 301 Moved Permanently  
영구적으로 리소스가 옮겨짐
- 302 Found  
일시적으로 리소스가 옮겨짐  
>301 302의 차이는 브라우저 캐시가 되고 말고의 차이 정도인거 같다.  
브라우저가 그렇게 정책을 가지고 있는지에 따라 다르겠지만 301은 같은 요청을 보내도 서버에게 요청하지 않고 캐시한 location으로 보내버림.  
302는 캐시하지 않고 매번 다시 요청함.
- 304 Not Modified  
일반적인 리다이렉션은 아니고, 캐시된 페이지를 검증하는데, 변경이 없으면 304를 보내고 브라우저는 캐시된 내용을 보여준다.  
둘이 다르다면 새 리소스를 전송해준다.  
리소스 전송, 로딩시간을 줄일수 있다.

- 400 Bad Request  
사용자의 잘못으로 요청을 처리할수 없는 경우.
그냥 범용적으로 쓰기도 한다.
- 401 Unauthorized  
리소스에 접근하기 위해 **인증**이 필요한 경우
- 403 Forbidden  
리소스에 접근하기 위한 **권한**이 없는 경우
> 401 과 403은 다르다. 사용자가 누군지 밝히는게 인증, 사용자에게 권한이 있는지 확인하는게 인가  
401은 인증이 필요한것이고, 403은 인가가 필요하다.
- 405 Method Not Allowed  
리소스 주소는 맞는데, 보낸 메서드가 허용되지 않은 경우.
- 406 Not Acceptable  
요청에 실어보낸 헤더 Accept 가 허용되지 않은 경우. 일반적으로 서버 개발자가 해당 타입의 리턴을 구현하지 않았을 경우.
- 415 Unsupported Media Type  
요청에 실어보낸 헤더 Content-Type 을 서버가 이해할수 없는 경우. 마찬가지로 서버 개발자가 해당 타입의 인풋 처리를 구현하지 않았을 경우.
- 409 Conflict  
요청 충돌. 구현은 서버 개발자의 마음이긴 하나 보통 POST, PUT 요청을 보냈을때 해당 리소스가 이미 존재하는 경우
- 411 Length Required  
요청이 제대로 받아진건지 Content-Length를 이용해 확인할수 있는데, 해당 헤더가 없는 경우
- 414 Request URI Too Long  
일반적 웹서버의 URL 최대길이는 2048바이트인데, 이를 넘어선 경우.  
한글 제목을 URL로 사용하는 블로그, queryparam이 복잡하거나 한글일 경우 발생할수 있다.

- 500 Internal Server Error  
서버에서 요청을 처리할수 없는 경우.
개발자가 따로 에러처리를 안해준 경우 많이 볼수 있음.  
게으르다면 범용적으로 쓰기도 함.
- 502 Bad Gateway
서버가 게이트웨이로부터 잘못된 응답 수신. 보통은 서버 터지기 직전에 많이 보임.(경험)
- 503 Server Unavailable
게이트웨이가 서버에 연결할수 없거나 서버가 현재 해당 요청을 처리해줄수 없는 경우. 보통은 502에 이어 서버가 터진 경우 볼수 있음.(경험)


##### 헤더
일반헤더 요청헤더 응답헤더 엔티티헤더 등등 나뉘는데 사실 구분하는거 자체가 별 의미 없다 생각됨.  
용도에 따라 주요 몇 헤더만 기억해 두자.

##### 주의 
헤더 Accept 와 Content-Type 은 다르다.  
둘다 MIME 타입을 사용하지만 용도가 다르다.  
Accept 는 서버에게서 받고싶은 타입을 명시하고, Content-Type은 본문의 콘텐츠 타입이다.

- Server  
응답을 해준 서버의 종류와 버전. 보통은 보안 위협이 되므로 꺼둔다.
- Pragma  
HTTP/1.0 부터 사용되었던 응답 헤더, 클라이언트에게 해당 응답을 캐시하지 말지를 지시한다.
HTTP/1.1 부터 cache-control 헤더가 추가되어 사용되지 않음.
구형 클라이언트를 위해 지원중.
- Cache-Control  
클라이언트에게 전하는 응답 헤더, 캐시 동작 지시.
몇가지 예약?지시어가 있는데
    - max-age 캐시 수명(초) 지정
    - no-cache 캐시함. 사용하기 전에 서버에 검증을 요청
    - no-store 항상 새로 받아옴. 일반적으로 생각하는 노 캐시
https://toss.tech/article/smart-web-service-cache
설명 잘됌 
- Max-Forwards  
요청이 서버로 바로 전송되는 경우 말고, 중간 전달자가 존재하는 경우 너무 많은 리다이렉션을 방지하기 위해 사용한다.  
요청이 전달자에게 전달 되는경우 max-forwards 값은 1씩 감소하며 0이 되면 해당 요청은 더이상 전달되지 않는다.   
기본값은 20이다.
- Location  
응답 상태 코드가 3xx일시, 어디로 리다이렉션을 해야하는지 알려줌.
- ETag  
엔티티태그라고 읽으며, 응답 헤더.  
캐시된 컨텐츠의 버전이라고 생각해야할듯 하다. 캐시된 컨텐츠의 ETag 값을 서버에 검증하여 새 버전을 받아와야하는지 판단하는데 사용한다.

Accept-xxx 시리즈, Content-xxx 시리즈는 보통 서버와 클라이언트끼리 이야기가 된 상태에서 개발하기 때문에 등한시 하기 쉬운데, 중요하다.


https://httpstat.us  
https://mock.codes  
자신이 개발한 http 클라이언트의 http status code 에 따른 동작을 테스트해야할때 사용하자.